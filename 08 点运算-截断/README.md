# 课程 08：点运算——截断（Truncation）

> 适合人群：零基础初学者 | 预计阅读时间：20 分钟

---

## 一、本课目标

本课你将学会：

1. 理解**截断（Truncation）** 的概念——给像素值设上限
2. 使用 `cv::threshold` 的 `THRESH_TRUNC` 模式
3. 理解截断在图像处理中的实际应用

---

## 二、什么是截断？

### 2.1 截断的直观理解

**截断 = 给像素值设一个"天花板"，超过的部分一律砍掉**

```
类比——限速：

  公路限速 120 km/h：
    实际车速  80  →  不变   → 80
    实际车速 100  →  不变   → 100
    实际车速 120  →  不变   → 120
    实际车速 150  →  限为120 → 120  ← 超速被截断了
    实际车速 200  →  限为120 → 120  ← 也被截断了

  同理，截断阈值 = 120 的图像处理：
    像素值 80   →  不变   → 80
    像素值 100  →  不变   → 100
    像素值 120  →  不变   → 120
    像素值 150  →  截为120 → 120  ← 被截断了
    像素值 255  →  截为120 → 120  ← 也被截断了
```

### 2.2 截断的数学定义

$$
\text{dst}(x,y) = \begin{cases} \text{src}(x,y) & \text{if } \text{src}(x,y) \leq T \\ T & \text{if } \text{src}(x,y) > T \end{cases}
$$

其中 $T$ 是截断阈值。

```
用曲线表示截断的映射关系：

  输出值
  255│
     │
     │
  T  │─ ─ ─ ─ ─ ─ ────────────────  ← 超过 T 的全变成 T
     │           ╱
     │         ╱
     │       ╱     ← 低于 T 的保持不变（斜率 = 1）
     │     ╱
     │   ╱
     │ ╱
   0 ┼╱───────────┬──────────────▶ 输入值
     0            T             255

  对比其他阈值操作的曲线：

  截断 TRUNC:        二值化 BINARY:       反二值化 BINARY_INV:
  T│───────          255│   ┌─────       255│─────┐
   │  ╱                 │   │                │     │
   │╱                  0│───┘              0 │     └───
   └───────            └───────             └───────
   保留低于T的          非黑即白              非白即黑
```

### 2.3 视觉效果

```
原图（灰度渐变）：
  灰度: 0   50  100  150  200  250  255
       ░░░  ▒▒▒  ▒▓▓  ▓▓▓  ███  ███  ███

截断后（T=120）：
  灰度: 0   50  100  120  120  120  120
       ░░░  ▒▒▒  ▒▓▓  ▒▓▓  ▒▓▓  ▒▓▓  ▒▓▓
                      ↑
                    阈值 T=120
                    所有 >120 的都变成 120

效果：高光部分被"削平"了，画面整体变暗
      暗部细节完全保留
      亮部细节全部丢失（变成同一个灰度值）
```

---

## 三、cv::threshold 函数

### 3.1 函数签名

```cpp
double cv::threshold(const cv::Mat& src,   // 输入（单通道）
                     cv::Mat& dst,          // 输出
                     double thresh,         // 阈值 T
                     double maxval,         // 最大值（TRUNC 模式不用这个）
                     int type);             // 阈值类型
```

### 3.2 五种阈值类型

| 类型 | 效果 | 公式 | 图示 |
|------|------|------|------|
| `THRESH_BINARY` | 高于阈值→白，低于→黑 | $dst = (src > T)$ ? maxval : 0 | 二值化 |
| `THRESH_BINARY_INV` | 高于阈值→黑，低于→白 | $dst = (src > T)$ ? 0 : maxval | 反二值化 |
| **`THRESH_TRUNC`** | **高于阈值→截为T** | **$dst = \min(src, T)$** | **本课** |
| `THRESH_TOZERO` | 低于阈值→变为 0 | $dst = (src > T)$ ? src : 0 | 保留亮部 |
| `THRESH_TOZERO_INV` | 高于阈值→变为 0 | $dst = (src > T)$ ? 0 : src | 保留暗部 |

```
五种阈值类型的映射曲线：

BINARY:      BINARY_INV:   TRUNC:       TOZERO:      TOZERO_INV:
max│  ┌──    max│──┐        T│──────     │   ╱         │╲
   │  │        │  │         │╱          │  ╱          │ ╲
  0│──┘       0│  └──      0│           │╱0           │  ╲0
   └──T──      └──T──       └──T──      └──T──        └──T──

  >T→白       >T→黑        >T→T        ≤T→0          >T→0
  ≤T→黑       ≤T→白        ≤T→不变      >T→不变       ≤T→不变
```

#### 五种阈值类型——像素值变换速查表

以 T=120 为例，观察不同输入像素经过五种类型后的输出：

| 输入像素 | BINARY | BINARY_INV | **TRUNC** | TOZERO | TOZERO_INV |
|:-------:|:------:|:----------:|:---------:|:------:|:----------:|
| **30** | 0 | 255 | **30** | 0 | 30 |
| **80** | 0 | 255 | **80** | 0 | 80 |
| **120** | 0 | 255 | **120** | 0 | 120 |
| **150** | 255 | 0 | **120** | 150 | 0 |
| **200** | 255 | 0 | **120** | 200 | 0 |
| **255** | 255 | 0 | **120** | 255 | 0 |

> 规律：TRUNC 列中 ≤120 的保持原值，>120 的全部变成 120 —— 就是"天花板"效果。

### 3.3 本课代码

```cpp
const double thresholdValue = 120.0;
cv::Mat truncated;
cv::threshold(gray, truncated, thresholdValue, 255.0, cv::THRESH_TRUNC);
//                              ↑               ↑            ↑
//                         阈值T=120     maxval不影响    截断模式
```

> `THRESH_TRUNC` 模式下 `maxval` 参数没有实际作用（截断值直接用 `thresh`），但 API 要求必须传，通常写 255。

---

## 四、截断的应用场景

### 4.1 高光压缩

```
场景：拍照时天空/灯光过曝

  原图：                截断后（T=200）：
  ┌──────────────┐     ┌──────────────┐
  │☀️ 255 255 255│     │☀️ 200 200 200│  ← 过曝区域被压暗
  │🏠 150 120 80 │     │🏠 150 120 80 │  ← 正常区域不变
  │🌳  50  80 30 │     │🌳  50  80 30 │  ← 暗部不变
  └──────────────┘     └──────────────┘

  用途：粗略的高光恢复（专业软件用更复杂的 tone mapping）
```

### 4.2 数据预处理

```
场景：传感器数据有异常高值（噪声/溢出）

  原始数据：  [45, 62, 38, 999, 55, 71, 888, 49]
                           ↑              ↑
                        异常值          异常值

  截断后（T=100）：[45, 62, 38, 100, 55, 71, 100, 49]
                               ↑              ↑
                           被限制在 100      被限制在 100
```

### 4.3 配合其他操作使用

```
截断常常作为图像处理流水线中的一个步骤：

  原图 ──▶ 高斯模糊 ──▶ 截断（去高光）──▶ 对比度拉伸 ──▶ 输出
                          ↑
                     消除过亮区域
                     让后续处理更均匀
```

---

## 五、截断 vs 其他亮度调整方法

| 方法 | 效果 | 特点 |
|------|------|------|
| **截断** (TRUNC) | 硬切高光 | 简单粗暴，亮部细节全丢 |
| Gamma 校正 (γ>1) | 压暗整体 | 非线性，保留亮部层次 |
| 直方图均衡化 | 重新分配 | 可能过度增强 |
| 对比度拉伸 | 线性拉伸到全范围 | 均匀拉伸，不丢信息 |

#### 亮度调整方法详细对比

| 维度 | 截断 (TRUNC) | Gamma(γ>1) | 直方图均衡化 | 对比度拉伸 |
|:----:|:-----------:|:----------:|:----------:|:---------:|
| **函数** | `threshold` | `convertTo`+pow | `equalizeHist` | `convertTo` |
| **映射类型** | 分段线性 | 幂函数（非线性） | CDF（非线性） | 线性 |
| **参数** | 阈值 T | γ 值 | 无参数 | min, max |
| **暗部处理** | ✅ 完全保留 | ⚠️ 压缩更暗 | ⚠️ 重新分布 | ✅ 等比拉伸 |
| **亮部处理** | ❌ 全部截为 T | ✅ 压暗但保留层次 | ⚠️ 重新分布 | ✅ 等比拉伸 |
| **信息损失** | 高（亮部全丢） | 低 | 中（间距变） | 低 |
| **适用场景** | 高光压制/去噪 | 整体偏亮图像 | 低对比度图像 | 灰度范围窄 |

```
各方法对同一个高光像素的处理：

  原始值 = 200，目标：让它不那么亮

  截断(T=150):     200 → 150  （硬切，所有 >150 的都是 150）
  Gamma(γ=2.0):    200 → 155  （非线性压缩，仍有层次）
  线性缩放(×0.8):  200 → 160  （等比缩放）

  截断最简单但信息损失最大
```

---

## 六、动手实验

### 实验 1：不同阈值的效果

```cpp
for (int t = 50; t <= 200; t += 50) {
    cv::Mat result;
    cv::threshold(gray, result, t, 255, cv::THRESH_TRUNC);
    cv::imshow("Trunc T=" + std::to_string(t), result);
}
// T=50: 大部分被截断，画面很暗
// T=100: 中间调以上被截断
// T=150: 只有高光被截断
// T=200: 只有最亮的部分被截断
```

### 实验 2：对比五种阈值类型

```cpp
int types[] = {cv::THRESH_BINARY, cv::THRESH_BINARY_INV, 
               cv::THRESH_TRUNC, cv::THRESH_TOZERO, cv::THRESH_TOZERO_INV};
std::string names[] = {"BINARY", "BINARY_INV", "TRUNC", "TOZERO", "TOZERO_INV"};

for (int i = 0; i < 5; i++) {
    cv::Mat result;
    cv::threshold(gray, result, 120, 255, types[i]);
    cv::imshow(names[i], result);
}
```

---

## 七、常见问题

| 问题 | 原因 | 解决方法 |
|------|------|---------|
| 截断后图片全是同一个灰度 | 阈值太低，所有像素都被截断了 | 增大阈值 |
| 截断后看不出变化 | 阈值太高，没有像素超过阈值 | 减小阈值 |
| 只能处理灰度图 | threshold 只接受单通道输入 | 先 cvtColor 转灰度 |
| 想截断暗部而不是亮部 | TRUNC 只截断亮部 | 用 TOZERO 或翻转图片 |

---

## 八、术语表

| 术语 | 英文 | 含义 |
|------|------|------|
| 截断 | Truncation | 超过阈值的像素值被限制为阈值 |
| 阈值 | Threshold | 判断的临界值 |
| 高光 | Highlight | 图片中最亮的区域 |
| 裁剪 | Clipping | 值被强制限制在某个范围内 |
| 映射函数 | Transfer Function | 输入值→输出值的对应关系 |

---

## 九、知识地图

```
  ⑥ Gamma 校正 → ⑦ 直方图均衡化 → ⑧ 截断 → ⑨ 颜色调整
                                    ★ 本课
                                        → ⑩ 反相
                                        → ⑪ 二值化（同样用 threshold！）
                                        → ⑫ 对比度拉伸

  本课的 cv::threshold 函数在课程 11（二值化）中会再次使用。
  五种 threshold 模式在本课全部介绍了，是后续课程的基础。

  阈值操作家族：
  截断(本课) → 二值化(课程11) → Otsu 自动阈值
```

---

## 十、记忆口诀

```
🧠 截断核心：

  "超过天花板，一律给砍掉"
  dst = min(src, T) — 就这么简单

🧠 五种阈值模式：

  "二反截零反零" → 记住五种的缩写
  BINARY / BINARY_INV / TRUNC / TOZERO / TOZERO_INV

  或者按效果记：
  "二值非黑即白，截断削平亮部，
   归零保留亮部，反零保留暗部"

🧠 threshold 参数：

  "源目阈最型" → src, dst, thresh, maxval, type
  TRUNC 模式下 maxval 没用，但还是得写
```

---

## 十一、新手雷区

```cpp
// ❌ 雷区 1：以为 THRESH_TRUNC 用的是 maxval
cv::threshold(gray, dst, 120, 200, cv::THRESH_TRUNC);
// 新手以为截断到 200，实际截断到 120（thresh 值）！
// maxval 在 TRUNC 模式下被忽略

// ✅ 正确理解：TRUNC 的截断值 = thresh 参数
cv::threshold(gray, dst, 120, 255, cv::THRESH_TRUNC);
// 所有 >120 的都变成 120
```

```cpp
// ❌ 雷区 2：对彩色图直接 threshold
cv::threshold(colorImage, dst, 120, 255, cv::THRESH_TRUNC);
// 多通道图调 threshold 行为可能不符合预期

// ✅ 正确：先转灰度
cv::Mat gray;
cv::cvtColor(colorImage, gray, cv::COLOR_BGR2GRAY);
cv::threshold(gray, dst, 120, 255, cv::THRESH_TRUNC);
```

```cpp
// ❌ 雷区 3：用截断压暗部（想让暗部变更暗）
cv::threshold(gray, dst, 50, 255, cv::THRESH_TRUNC);
// TRUNC 只能削亮部！暗部（<50的）完全不受影响

// ✅ 正确：想让暗部变0，用 THRESH_TOZERO
cv::threshold(gray, dst, 50, 255, cv::THRESH_TOZERO);
// 所有 ≤50 的变成 0，>50 的保持不变
```

---

## 十二、思考题

1. **截断阈值设为 255 会怎样？设为 0 又会怎样？**
   提示：T=255 → 没有像素 >255 → 无变化。T=0 → ？

2. **如何实现"截断暗部"——让所有低于 T 的像素变成 T？**
   提示：OpenCV 没有直接的模式，但可以用 `cv::max(src, T)` 实现。

3. **截断和 `cv::min` 函数有什么关系？**
   提示：`THRESH_TRUNC` 本质上就是 `dst = min(src, T)`。

---

## 十三、速查卡片

```
┌─────────────────── 课程 08 速查 ───────────────────┐
│                                                    │
│  截断:                                              │
│    cv::threshold(src, dst, T, 255, THRESH_TRUNC);  │
│    效果: dst = min(src, T)                         │
│                                                    │
│  五种阈值类型:                                      │
│    BINARY     → >T ? 255 : 0    非黑即白           │
│    BINARY_INV → >T ? 0 : 255    反向二值化          │
│    TRUNC      → >T ? T : src    截断亮部 ← 本课    │
│    TOZERO     → >T ? src : 0    暗部归零            │
│    TOZERO_INV → >T ? 0 : src    亮部归零            │
│                                                    │
│  注意: TRUNC 模式下 maxval 参数无效                  │
│                                                    │
└────────────────────────────────────────────────────┘
```

---

## 十四、延伸阅读

- [cv::threshold 文档](https://docs.opencv.org/4.x/d7/d1b/group__imgproc__misc.html#gae8a4a146d1ca78c626a53577199e9c57) — 五种阈值模式的完整说明
- [阈值操作教程](https://docs.opencv.org/4.x/d7/d4d/tutorial_py_thresholding.html) — OpenCV 官方阈值教程
- [cv::min 文档](https://docs.opencv.org/4.x/d2/de8/group__core__array.html#ga9af368f182ee76d0c11e44571d93d1c4) — 逐元素取最小值
