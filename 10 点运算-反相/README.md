# 课程 10：点运算——反相（Invert / Negative）

> 适合人群：零基础初学者 | 预计阅读时间：18 分钟

---

## 一、本课目标

本课你将学会：

1. 理解**反相（Invert）** 的数学本质——用 255 减去每个像素值
2. 使用 `cv::bitwise_not` 实现反相
3. 了解反相在图像处理中的经典应用

---

## 二、什么是反相？

### 2.1 直观理解

**反相 = 把所有颜色"翻转"，黑变白、白变黑、亮变暗、暗变亮。**

```
类比——胶片底片：

  ┌──── 正片（照片） ────┐      ┌──── 底片（反相） ────┐
  │                      │      │                       │
  │  白色天空 (255)      │      │  黑色天空 (0)         │
  │  灰色建筑 (128)      │      │  灰色建筑 (127)       │
  │  黑色轮廓 (0)        │      │  白色轮廓 (255)       │
  │                      │      │                       │
  └──────────────────────┘      └───────────────────────┘

  正片 ←──互为反相──→ 底片
```

### 2.2 数学定义

$$
\text{dst}(x,y) = 255 - \text{src}(x,y)
$$

```
反相映射表（部分示例）：

  输入 →  输出
  ─────────────
    0  →  255    黑 → 白
   50  →  205    深灰 → 浅灰
  100  →  155    灰 → 灰
  127  →  128    中灰 → 中灰（几乎不变！）
  128  →  127    中灰 → 中灰
  200  →   55    浅灰 → 深灰
  255  →    0    白 → 黑
```

### 2.3 映射曲线

```
  输出值
  255│╲
     │ ╲
     │  ╲
  128│   ╲          ← 斜率 = -1
     │    ╲            直线从 (0,255) 到 (255,0)
     │     ╲
     │      ╲
   0 │───────╲──────▶ 输入值
     0  128  255

  对比其他点运算的曲线：

  恒等:      反相:      Gamma(>1):   截断:
  │  ╱       │╲         │    ╱       T│──────
  │ ╱        │ ╲        │  ╱╱        │╱
  │╱         │  ╲       │╱╱         0│
  └───       └───╲      └───         └──T──
  y=x       y=255-x    y=x^γ       y=min(x,T)
```

### 2.4 灰度反相效果

```
原图（8个像素的灰度值）：
  [ 20 ] [ 60 ] [100] [140] [180] [200] [230] [255]
    ░      ▒      ▒     ▓     ▓     █     █     █

反相后：
  [235] [195] [155] [115] [ 75] [ 55] [ 25] [  0]
    █     █     ▓     ▒     ▒     ░     ░     ·

  暗的变亮了 ↑              亮的变暗了 ↑
```

### 2.5 彩色反相

```
彩色反相 = 对每个通道（B, G, R）分别做 255 - x

原始像素：  B=100, G= 50, R=200    （偏红紫色）
反相后：    B=155, G=205, R= 55    （偏青绿色）

  原色和反色互为"补色"！

  ┌──────────────────────────────┐
  │  红 (255,0,0) ↔ 青 (0,255,255) │
  │  绿 (0,255,0) ↔ 品红(255,0,255)│
  │  蓝 (0,0,255) ↔ 黄 (255,255,0) │
  │  白 (255,255,255) ↔ 黑 (0,0,0) │
  └──────────────────────────────┘
```

#### 常见颜色反相速查表

| 原始颜色 | BGR 值 | 反相后 BGR | 反相颜色 | 关系 |
|:-------:|:------:|:---------:|:-------:|:----:|
| 🔴 红 | (0, 0, 255) | (255, 255, 0) | 🔵 青 | 互补 |
| 🟢 绿 | (0, 255, 0) | (255, 0, 255) | 🟣 品红 | 互补 |
| 🔵 蓝 | (255, 0, 0) | (0, 255, 255) | 🟡 黄 | 互补 |
| ⬛ 黑 | (0, 0, 0) | (255, 255, 255) | ⬜ 白 | 明暗翻转 |
| ⬜ 白 | (255, 255, 255) | (0, 0, 0) | ⬛ 黑 | 明暗翻转 |
| 🟠 橙 | (0, 165, 255) | (255, 90, 0) | 蓝偏色 | — |
| 灰 128 | (128, 128, 128) | (127, 127, 127) | 灰 127 | 几乎不变 |
| 肤色 | (120, 160, 210) | (135, 95, 45) | 暗蓝 | — |

> 规律：任意像素 `(B,G,R)` 反相后为 `(255-B, 255-G, 255-R)`，两者相加恒等于 `(255,255,255)`。

---

## 三、bitwise_not 详解

### 3.1 函数签名

```cpp
void cv::bitwise_not(const cv::Mat& src, cv::Mat& dst);
```

### 3.2 为什么叫"bitwise"？

```
bitwise_not 按位取反，对每个 bit 做 NOT（0→1, 1→0）

以像素值 200 为例：

  十进制：200
  二进制：1 1 0 0 1 0 0 0

  按位取反：
           1 1 0 0 1 0 0 0   ← 原始
    NOT →  0 0 1 1 0 1 1 1   ← 取反

  取反结果：
  二进制：0 0 1 1 0 1 1 1
  十进制：55

  验证：200 + 55 = 255 ✅

  对于 uint8（0~255），按位取反 ≡ 255 - x

  证明：
    一个 8 位数 x 的按位取反 = ~x
    x + ~x = 11111111₂ = 255
    所以 ~x = 255 - x  ✅
```

### 3.3 按位运算家族

```
OpenCV 提供四种按位运算：

  ┌──────────────────┬────────┬──────────────────┐
  │ 函数              │ 运算    │ 像素级效果         │
  ├──────────────────┼────────┼──────────────────┤
  │ bitwise_and      │ A & B  │ 遮罩/提取区域      │
  │ bitwise_or       │ A | B  │ 合并区域           │
  │ bitwise_xor      │ A ^ B  │ 差异检测           │
  │ bitwise_not      │ ~A     │ 反相/颜色翻转      │
  └──────────────────┴────────┴──────────────────┘

  本课只用 bitwise_not
```

---

## 四、实现反相的多种方法

```
方法 1：bitwise_not（推荐，最快）
  cv::bitwise_not(src, dst);

方法 2：标量减法
  dst = cv::Scalar::all(255) - src;

方法 3：用 convertTo
  src.convertTo(dst, -1, -1.0, 255);
  // dst = src * (-1) + 255 = 255 - src

方法 4：手动遍历（最慢，仅演示）
  for (int r = 0; r < src.rows; r++)
      for (int c = 0; c < src.cols; c++)
          dst.at<uchar>(r,c) = 255 - src.at<uchar>(r,c);
```

```
性能对比（大致参考值，640×480 灰度图）：

  方法           耗时（相对值）
  ─────────────────────────
  bitwise_not    1.0×  ← 最快（SIMD）
  Scalar 减法     1.2×
  convertTo      1.3×
  手动遍历       10×+  ← 最慢
```

#### 反相实现方法对比

| 维度 | `bitwise_not` | `Scalar(255)-src` | `convertTo` | 手动遍历 |
|:----:|:------------:|:-----------------:|:-----------:|:-------:|
| **代码量** | 1 行 | 1 行 | 1 行 | 4+ 行 |
| **速度** | ⚡ 最快 | 🔵 快 | 🔵 快 | 🐌 慢 |
| **SIMD加速** | ✅ 有 | ✅ 有 | ✅ 有 | ❌ 无 |
| **支持多通道** | ✅ | ✅ | ✅ | ⚠️ 需逐通道 |
| **支持 float** | ❌ 无意义 | ✅ | ✅ | ✅ |
| **推荐度** | ⭐⭐⭐ | ⭐⭐ | ⭐⭐ | ⭐ |

---

## 五、反相的应用

### 5.1 医学影像

```
X 光片通常是黑底白骨，反相后更直观：

  原始 X 光：              反相后：
  ┌──────────────┐        ┌──────────────┐
  │ ██████████████│        │              │
  │ ████  骨  ████│        │    ░░骨░░    │
  │ ██████████████│        │              │
  │ ████  骨  ████│  →→→   │    ░░骨░░    │
  │ ██████████████│        │              │
  └──────────────┘        └──────────────┘
   黑底白骨                 白底暗骨
   （传统胶片风格）          （更接近打印习惯）
```

### 5.2 掩膜反转

```
场景：有一个前景掩膜，想得到背景掩膜

  前景掩膜：                反相 → 背景掩膜：
  ┌──────────────┐         ┌──────────────┐
  │ 0  0  0  0  0│         │255 255 255 255│
  │ 0 255 255  0 │         │255  0   0  255│
  │ 0 255 255  0 │   ──▶   │255  0   0  255│
  │ 0  0  0  0  0│         │255 255 255 255│
  └──────────────┘         └──────────────┘
   白色=前景                 白色=背景

  bitwise_not(foreground_mask, background_mask);
```

### 5.3 双重反相 = 原图

```
反相的一个重要性质：做两次反相 = 恢复原图

  第一次反相：  dst1 = 255 - src
  第二次反相：  dst2 = 255 - dst1 = 255 - (255 - src) = src

  这叫做"对合运算"（Involution）：f(f(x)) = x

  验证：像素值 80
    第一次反相：255 - 80  = 175
    第二次反相：255 - 175 = 80  ✅ 恢复了！
```

### 5.4 视觉效果/艺术

```
反相可以产生"底片"风格的艺术效果：

  ┌─────── 正常照片 ────────┐    ┌────── 反相效果 ──────┐
  │  蓝色天空               │    │  橙色天空（补色）     │
  │  绿色树木               │    │  品红树木（补色）     │
  │  红色花朵               │    │  青色花朵（补色）     │
  │  黑色阴影               │    │  白色阴影（高光）     │
  └─────────────────────────┘    └──────────────────────┘
```

---

## 六、代码精读

本课源码的核心就一行：

```cpp
cv::bitwise_not(gray, inverted);
```

完整流程：

```
┌──────────────────────────────────────────────┐
│ 1. 读取原图      cv::imread("cat.jpg")        │
│ 2. 显示原图      imshow("原图", src)           │
│ 3. 反相          bitwise_not(src, inverted)    │
│ 4. 显示反相      imshow("反相", inverted)      │
└──────────────────────────────────────────────┘
```

---

## 七、动手实验

### 实验 1：彩色反相

```cpp
// 不需要先转灰度！直接对彩色图像反相
cv::Mat color = cv::imread("cat.jpg");
cv::Mat inv;
cv::bitwise_not(color, inv);
cv::imshow("Color Inverted", inv);
// 观察：红变青，绿变品红，蓝变黄
```

### 实验 2：验证双重反相

```cpp
cv::Mat inv1, inv2;
cv::bitwise_not(src, inv1);  // 第一次反相
cv::bitwise_not(inv1, inv2); // 第二次反相

// 验证 inv2 == src
cv::Mat diff;
cv::absdiff(src, inv2, diff);
double maxDiff = cv::sum(diff)[0];
std::cout << "差异总和: " << maxDiff << std::endl;
// 输出应该是 0（完全相同）
```

### 实验 3：局部反相

```cpp
// 只反相图像的上半部分
cv::Mat top_half = src(cv::Rect(0, 0, src.cols, src.rows / 2));
cv::bitwise_not(top_half, top_half);
// 效果：上半部分是底片，下半部分是正片
```

---

## 八、常见问题

| 问题 | 原因 | 解决方法 |
|------|------|---------|
| 反相后全白或全黑 | 输入图像本身就是纯黑/纯白 | 检查输入图像 |
| 彩色反相颜色奇怪 | 这是正常现象（补色效果） | 颜色翻转是反相的特性 |
| 反相后显示乱码 | Mat 类型不是 CV_8U | 先转换为 8 位图像 |
| 想只反相某个通道 | bitwise_not 对所有通道操作 | 先 split，只反相一个通道 |

---

## 九、术语表

| 术语 | 英文 | 含义 |
|------|------|------|
| 反相 | Invert / Negative | 每个像素值变为 255 减去自身 |
| 按位取反 | Bitwise NOT | 对每个二进制位做 NOT 运算 |
| 补色 | Complementary Color | 两种颜色混合后为白色 |
| 对合 | Involution | 做两次同一操作后恢复原值 |
| 掩膜 | Mask | 用于选择图像区域的二值图 |
| 底片 | Negative Film | 明暗/颜色都与正片相反的胶片 |

---

## 十、知识地图

```
  ⑦ 直方图 → ⑧ 截断 → ⑨ 颜色调整 → ⑩ 反相 → ⑪ 二值化
                                      ★ 本课

  反相是最简单的点运算之一（一行代码）。
  但理解 bitwise 运算对后续的掩膜操作很重要。

  按位运算家族：
  NOT(本课) → AND(掩膜提取) → OR(区域合并) → XOR(差异检测)
```

---

## 十一、记忆口诀

```
🧠 反相核心：

  "二五五减去它，黑白颠倒花"
  dst = 255 - src
  等价于 bitwise_not

🧠 补色规律：

  "红青绿品蓝黄，互为补色成一双"
  红(255,0,0) ↔ 青(0,255,255)
  绿(0,255,0) ↔ 品红(255,0,255)
  蓝(0,0,255) ↔ 黄(255,255,0)

🧠 对合性质：

  "反相两次变回原，NOT NOT 等于没做"
  bitwise_not(bitwise_not(x)) == x
```

---

## 十二、新手雷区

```cpp
// ❌ 雷区 1：用减法做反相（可能溢出）
cv::Mat inverted = 255 - src;
// 理论上 OK，但如果 src 不是 CV_8U 类型可能出问题

// ✅ 推荐：直接用 bitwise_not
cv::bitwise_not(src, inverted);  // 类型安全，最快
```

```cpp
// ❌ 雷区 2：对 float 类型的图像用 bitwise_not
cv::Mat floatImg;
src.convertTo(floatImg, CV_32F, 1.0/255);
cv::bitwise_not(floatImg, result);
// 对浮点数做位取反 → 结果毫无意义！

// ✅ 正确：float 图像用减法
cv::Mat result = cv::Scalar(1.0) - floatImg;
```

```cpp
// ❌ 雷区 3：反相后没意识到原图被修改了
cv::bitwise_not(src, src);  // 原图被覆盖了！
// 之后想用原图就没了

// ✅ 正确：输出到新 Mat
cv::Mat inverted;
cv::bitwise_not(src, inverted);  // 原图不变
```

---

## 十三、思考题

1. **灰度值 128 做反相后变成多少？127 呢？**
   提示：255-128=127, 255-127=128。中间值几乎不变！

2. **如果对一张二值图（只有 0 和 255）做反相，效果等同于什么？**
   提示：0→255, 255→0 = 黑白互换。

3. **`bitwise_not` 和 `threshold(BINARY_INV)` 在什么情况下效果一样？**
   提示：对二值图来说……

---

## 十四、速查卡片

```
┌─────────────────── 课程 10 速查 ───────────────────┐
│                                                    │
│  反相（推荐）:                                      │
│    cv::bitwise_not(src, dst);                      │
│                                                    │
│  反相（等效方法）:                                   │
│    dst = cv::Scalar::all(255) - src;               │
│    src.convertTo(dst, -1, -1.0, 255);              │
│                                                    │
│  按位运算家族:                                      │
│    bitwise_not(a, dst)       NOT 取反              │
│    bitwise_and(a, b, dst)    AND 掩膜提取           │
│    bitwise_or(a, b, dst)     OR  区域合并           │
│    bitwise_xor(a, b, dst)    XOR 差异检测           │
│                                                    │
│  性质: NOT(NOT(x)) == x  （对合运算）              │
│  补色: R↔Cyan  G↔Magenta  B↔Yellow                │
│                                                    │
└────────────────────────────────────────────────────┘
```

---

## 十五、延伸阅读

- [cv::bitwise_not 文档](https://docs.opencv.org/4.x/d2/de8/group__core__array.html#ga0002cf8b418f068e4d928e1a6a52de48) — 按位取反函数
- [按位运算教程](https://docs.opencv.org/4.x/d0/d86/tutorial_py_image_arithmetics.html) — and/or/not/xor 综合教程
- [图像算术运算](https://docs.opencv.org/4.x/d2/de8/group__core__array.html) — add, subtract, absdiff 等
