# 课程 11：点运算——二值化（Binary Thresholding）

> 适合人群：零基础初学者 | 预计阅读时间：25 分钟

---

## 一、本课目标

本课你将学会：

1. 理解**二值化**——把灰度图变成只有黑(0)和白(255)两种颜色
2. 使用 `cv::threshold` 的 `THRESH_BINARY` 模式
3. 了解阈值选择的方法（手动 / Otsu 自动）
4. 知道二值化在 OCR、轮廓检测等场景的重要性

---

## 二、什么是二值化？

### 2.1 直观理解

**二值化 = 把灰度图变成"非黑即白"的图片。**

```
类比——考试及格线：

  及格线 = 60 分

  学生成绩：  85   72   45   60   30   91   55   100
  结果：      ✅   ✅   ❌   ✅   ❌   ✅   ❌   ✅
              及格  及格  不及格 及格 不及格 及格 不及格 及格

  只看"及格/不及格"，不管具体多少分 → 这就是二值化的思想！

  对应到图像：
    像素值 ≥ 阈值  →  白色 (255)   "及格"
    像素值 <  阈值  →  黑色 (0)     "不及格"
```

### 2.2 数学定义

$$
\text{dst}(x,y) = \begin{cases} 255 & \text{if } \text{src}(x,y) \geq T \\ 0 & \text{if } \text{src}(x,y) < T \end{cases}
$$

> 注：OpenCV 实际判断条件是 `src > T` 而非 `src >= T`，即像素值**严格大于** T 时为白色。

```
映射曲线：

  输出值
  255│         ┌──────────   ← 大于 T 的全变 255（白）
     │         │
     │         │
  128│         │
     │         │
     │         │
   0 │─────────┘             ← 不大于 T 的全变 0（黑）
     └─────────┬──────────▶ 输入值
               T

  这是一个"阶梯函数"（Step Function）
  只有两个可能的输出值：0 或 255
```

### 2.3 视觉效果

```
原图（灰度渐变）：
  [ 30 ] [ 80 ] [100] [128] [150] [180] [210] [250]
    ░      ▒      ▒     ▓     ▓     █     █     █

二值化后（T=128）：
  [  0 ] [  0 ] [  0 ] [  0 ] [255] [255] [255] [255]
    ·      ·      ·      ·     █     █     █     █

  ← 全黑 →              ← 全白 →
  像素值 ≤ 128           像素值 > 128

  中间过渡完全消失了！
  只剩下"黑色"和"白色"两种颜色
```

### 2.4 一个具体的例子

```
原图（5×5 灰度矩阵）：            二值化后（T=128）：

  ┌────┬────┬────┬────┬────┐     ┌────┬────┬────┬────┬────┐
  │ 45 │200 │180 │ 30 │ 10 │     │  0 │255 │255 │  0 │  0 │
  ├────┼────┼────┼────┼────┤     ├────┼────┼────┼────┼────┤
  │150 │220 │190 │ 60 │ 20 │     │255 │255 │255 │  0 │  0 │
  ├────┼────┼────┼────┼────┤     ├────┼────┼────┼────┼────┤
  │160 │240 │130 │ 50 │ 15 │     │255 │255 │255 │  0 │  0 │
  ├────┼────┼────┼────┼────┤     ├────┼────┼────┼────┼────┤
  │ 80 │170 │100 │ 25 │  5 │     │  0 │255 │  0 │  0 │  0 │
  ├────┼────┼────┼────┼────┤     ├────┼────┼────┼────┼────┤
  │ 40 │ 90 │ 70 │ 35 │ 55 │     │  0 │  0 │  0 │  0 │  0 │
  └────┴────┴────┴────┴────┘     └────┴────┴────┴────┴────┘

  灰度图有 256 级灰度              二值图只有 0 和 255
```

---

## 三、cv::threshold 函数

### 3.1 函数调用

```cpp
cv::threshold(gray, binary, 128, 255, cv::THRESH_BINARY);
//            输入   输出  阈值T maxval  模式
```

| 参数 | 本课的值 | 含义 |
|------|---------|------|
| `gray` | 灰度输入 | 单通道 8 位图像 |
| `binary` | 二值输出 | 只有 0 和 maxval |
| `128` | 阈值 T | 判断的分界线 |
| `255` | maxval | 大于阈值时的输出值 |
| `THRESH_BINARY` | 模式 | 大于 T → maxval，否则 0 |

### 3.2 与课程 08 截断的对比

```
课程 08 (TRUNC):              本课 (BINARY):
  ≤T → 保留原值                ≤T → 0（黑）
  >T → 变为 T                  >T → 255（白）

  保留了暗部细节              所有细节都没了
  只压制亮部                  只剩黑白两色

  T│──────                    255│   ┌─────
   │╱                            │   │
  0│                            0│───┘
   └──T──                       └──T──

  信息保留较多              信息极度压缩
  用于高光控制              用于分割/识别
```

---

## 四、阈值选择

### 4.1 阈值大小的影响

```
同一张图片，不同阈值的效果：

  T=50（太低）：        T=128（适中）：       T=200（太高）：
  ┌──────────┐         ┌──────────┐         ┌──────────┐
  │██ 大部分白██│         │█ 黑白均衡 █│         │  大部分黑  │
  │██████████│         │░░░████░░░│         │          │
  │██████████│         │░░████░░░░│         │    ██    │
  └──────────┘         └──────────┘         └──────────┘
   前景背景都是白         前景和背景分离         只有最亮保留

  阈值太低 → 几乎全白 → 没用
  阈值太高 → 几乎全黑 → 也没用
  阈值刚好 → 前景/背景清晰分离 → 完美！
```

### 4.2 如何选择阈值？

```
方法 1：手动选择

  看直方图，找"双峰"之间的"谷"：

  频率
  ↑
  │ ╱╲                ╱╲
  │╱  ╲              ╱  ╲
  │    ╲    谷      ╱    ╲
  │     ╲ ╱    ╲  ╱      ╲
  └──────╳──────╳────────╲──▶ 灰度值
         ↑      ↑
        背景    前景
         │
      T≈谷底位置

  直方图有两个"山峰"→ 对应背景和前景
  最佳阈值 ≈ 两峰之间谷底的灰度值
```

### 4.3 Otsu 自动阈值

```cpp
// Otsu 方法自动计算最佳阈值
double otsu_thresh = cv::threshold(gray, binary, 0, 255, 
                                   cv::THRESH_BINARY | cv::THRESH_OTSU);
//                                 ↑ 初始 T 被忽略      ↑ 加上 OTSU 标志
// otsu_thresh 返回计算出的最佳阈值
```

```
Otsu 算法原理（简化版）：

  目标：找到阈值 T，使前景和背景的"类间方差"最大

  换句话说：让黑色区域和白色区域的灰度差别尽可能大

  ┌─────────────────────────────────────────────┐
  │ 遍历所有可能的 T（0~255）                    │
  │   对于每个 T：                               │
  │     ① 计算背景（≤T）的平均灰度 μ₀ 和权重 ω₀ │
  │     ② 计算前景（>T）的平均灰度 μ₁ 和权重 ω₁  │
  │     ③ 类间方差 = ω₀·ω₁·(μ₀-μ₁)²            │
  │   选择使类间方差最大的 T                      │
  └─────────────────────────────────────────────┘

  优点：全自动，不需要人工调参
  缺点：假设直方图是双峰分布——不是双峰就不准
```

### 4.4 自适应阈值

```cpp
// 当光照不均匀时，全局阈值效果差
// 自适应阈值给每个像素计算局部阈值
cv::adaptiveThreshold(gray, binary, 255,
    cv::ADAPTIVE_THRESH_GAUSSIAN_C,  // 高斯加权
    cv::THRESH_BINARY,               // 二值化模式
    11,                               // 邻域大小（奇数）
    2);                               // 常数 C
```

```
全局阈值 vs 自适应阈值：

  光照不均匀的图像：         全局 T=128：          自适应阈值：
  ┌──────────────┐         ┌──────────────┐     ┌──────────────┐
  │ 亮区        暗区│         │████          │     │████    ████  │
  │ 文字A    文字B │  →→→   │████          │     │████    ████  │
  │ (200)    (80)  │         │              │     │              │
  └──────────────┘         └──────────────┘     └──────────────┘
                            暗区文字全丢了！       两边都保留！

  自适应阈值根据局部亮度决定 T
  → 亮区用高 T，暗区用低 T
  → 适合光照不均的场景
```

#### adaptiveThreshold 参数速查表

| 参数 | 可选值 | 含义 | 推荐起点 |
|:----:|:-----:|:----:|:-------:|
| `maxValue` | 0~255 | 大于局部阈值时的输出 | **255** |
| `adaptiveMethod` | `MEAN_C` | 邻域均值作阈值 | 简单场景 |
| | `GAUSSIAN_C` | 邻域高斯加权均值 | **推荐**，抗噪更好 |
| `thresholdType` | `BINARY` | >T→白，≤T→黑 | **常用** |
| | `BINARY_INV` | >T→黑，≤T→白 | 白底黑字 |
| `blockSize` | 3, 5, 7, 11, ... | 邻域窗口大小（奇数） | **11** |
| `C` | -10 ~ +10 | 从局部均值中减去的常数 | **2** |

```
blockSize 和 C 的影响：

  blockSize 小(3~5):   对局部变化敏感，细节多但噪声也多
  blockSize 大(21~51):  更平滑，细节少但更稳定

  C 大(5~10):    阈值升高，更多像素变黑（更严格）
  C 小(0~2):     阈值接近局部均值（标准）
  C 负值(-5):    阈值降低，更多像素变白（更宽松）
```

#### 阈值方法选择决策表

| 场景 | 推荐方法 | 理由 |
|:----:|:-------:|:----:|
| 光照均匀 + 双峰直方图 | `THRESH_OTSU` | 全自动，效果好 |
| 光照均匀 + 已知阈值 | `THRESH_BINARY` | 最简单 |
| 光照不均匀 | `adaptiveThreshold` | 局部自适应 |
| 不确定用什么 | 先试 Otsu → 不行再 adaptive | — |

---

## 五、二值化的应用

### 5.1 OCR 文字识别

```
  原始扫描文档：              二值化后：
  ┌──────────────────┐      ┌──────────────────┐
  │ ░░Hello░░░░░░░░░ │      │   Hello           │
  │ ░░░░░░░░░░░░░░░░ │  →   │                   │
  │ ░░World░░░░░░░░░ │      │   World           │
  │ ░░░░░░░░░░░░░░░░ │      │                   │
  └──────────────────┘      └──────────────────┘
   灰色背景+灰色文字          清晰的黑字白底
   OCR 识别率低               OCR 识别率高

  二值化是 OCR 的标准预处理步骤
```

### 5.2 轮廓检测

```
  findContours 要求二值输入！

  灰度图 → 二值化 → findContours → 轮廓
                      ↑
                  只能处理二值图
```

### 5.3 前景/背景分离

```
  场景：白色背景上的物体

  灰度图：                   二值化后（掩膜）：
  ┌──────────────────┐      ┌──────────────────┐
  │ 250 250 250 250  │      │  0   0   0   0   │
  │ 250  50  80 250  │  →   │  0  255 255  0   │
  │ 250  60  70 250  │      │  0  255 255  0   │
  │ 250 250 250 250  │      │  0   0   0   0   │
  └──────────────────┘      └──────────────────┘
   白底灰色物体               黑底白色掩膜
                              白色区域 = 物体所在位置
```

---

## 六、五种阈值类型对比

```
以阈值 T=128、像素值 p 为例：

  ┌──────────────────┬───────────┬───────────┬──────────────┐
  │ 类型              │ p=50      │ p=128     │ p=200        │
  ├──────────────────┼───────────┼───────────┼──────────────┤
  │ BINARY           │ 0 (黑)    │ 0 (黑)    │ 255 (白)     │
  │ BINARY_INV       │ 255 (白)  │ 255 (白)  │ 0 (黑)       │
  │ TRUNC (课程08)   │ 50        │ 128       │ 128          │
  │ TOZERO           │ 0         │ 0         │ 200          │
  │ TOZERO_INV       │ 50        │ 128       │ 0            │
  └──────────────────┴───────────┴───────────┴──────────────┘

  BINARY:      严格判断——非黑即白（本课）
  BINARY_INV:  反向判断——非白即黑
  TRUNC:       截断——超过的砍掉（课程08）
  TOZERO:      保留亮部——暗的变0
  TOZERO_INV:  保留暗部——亮的变0
```

---

## 七、二值图像的特点

```
1. 占用空间小
   灰度图：每像素 8 bit，256 种可能
   理想二值图：每像素 1 bit，2 种可能
   但 OpenCV 用 CV_8U 存储，每像素仍占 8 bit

2. 运算极快
   只有 0 和 255，可以用位运算代替数值运算
   AND / OR / NOT 速度极快

3. 信息高度压缩
   丢弃了所有灰度层次
   只保留"有/无"的信息

   ┌──── 信息量对比 ────┐
   │ 彩色图: 16M 种颜色  │
   │ 灰度图: 256 级灰度  │
   │ 二值图: 2 种值       │
   └─────────────────────┘
```

#### 图像类型数据量对比

| 图像类型 | 每像素比特 | 可能的值 | 640×480 大小 | 信息密度 |
|:-------:|:--------:|:-------:|:-----------:|:-------:|
| 彩色 (BGR) | 24 bit | 16,777,216 色 | 900 KB | ⬛⬛⬛⬛⬛ 最高 |
| 灰度 (8bit) | 8 bit | 256 级灰度 | 300 KB | ⬛⬛⬛ 中等 |
| 二值 (CV_8U) | 8 bit* | 仅 0 和 255 | 300 KB | ⬛ 最低 |
| 理论二值 | 1 bit | 仅 0 和 1 | 37.5 KB | ⬛ 最低 |

> *OpenCV 的二值图实际用 CV_8U (8bit) 存储，每像素浪费 7 bit，但运算兼容性好。

---

## 八、动手实验

### 实验 1：不同阈值的效果

```cpp
for (int t = 0; t <= 255; t += 50) {
    cv::Mat result;
    cv::threshold(gray, result, t, 255, cv::THRESH_BINARY);
    cv::imshow("T=" + std::to_string(t), result);
}
// 观察：T 越低，白色区域越多
//       T 越高，白色区域越少
```

### 实验 2：Otsu 自动阈值

```cpp
cv::Mat otsu_result;
double otsu_t = cv::threshold(gray, otsu_result, 0, 255,
                               cv::THRESH_BINARY | cv::THRESH_OTSU);
std::cout << "Otsu 自动阈值: " << otsu_t << std::endl;
// 对比手动 T=128 和 Otsu 自动选择的效果
```

### 实验 3：二值化 + 轮廓

```cpp
cv::Mat binary;
cv::threshold(gray, binary, 128, 255, cv::THRESH_BINARY);

std::vector<std::vector<cv::Point>> contours;
cv::findContours(binary, contours, cv::RETR_EXTERNAL, cv::CHAIN_APPROX_SIMPLE);
std::cout << "找到 " << contours.size() << " 个轮廓" << std::endl;

cv::drawContours(src, contours, -1, cv::Scalar(0, 255, 0), 2);
cv::imshow("Contours", src);
```

---

## 九、常见问题

| 问题 | 原因 | 解决方法 |
|------|------|---------|
| 二值化后全白 | 阈值太低，所有像素都大于 T | 增大阈值或用 Otsu |
| 二值化后全黑 | 阈值太高，所有像素都小于 T | 减小阈值或用 Otsu |
| 物体边缘锯齿严重 | 阈值太绝对，灰度过渡区域不稳定 | 先模糊再二值化，或用自适应阈值 |
| 光照不均匀效果差 | 全局阈值无法处理局部亮度差异 | 用 adaptiveThreshold |
| threshold 崩溃 | 输入不是单通道 | 先 cvtColor 转灰度 |

---

## 十、术语表

| 术语 | 英文 | 含义 |
|------|------|------|
| 二值化 | Binarization | 将灰度图转为只有 0 和 255 的图像 |
| 阈值 | Threshold | 区分前景和背景的临界灰度值 |
| 前景 | Foreground | 图像中感兴趣的目标区域 |
| 背景 | Background | 图像中不关注的区域 |
| Otsu | 大津法 | 自动计算最佳二值化阈值的算法 |
| 自适应阈值 | Adaptive Threshold | 为每个像素计算局部阈值的方法 |
| 阶梯函数 | Step Function | 只有两个输出值的跳变函数 |
| 类间方差 | Between-class Variance | 前景和背景平均灰度之差的加权平方 |
| 轮廓 | Contour | 物体边界的像素点集合 |

---

## 十一、知识地图

```
  ⑧ 截断 → ⑨ 颜色调整 → ⑩ 反相 → ⑪ 二值化 → ⑫ 对比度拉伸
                                    ★ 本课

  二值化是计算机视觉中最重要的预处理步骤之一！

  从 threshold 家族的角度：
  课程 08（TRUNC 截断）→ 本课（BINARY 二值化）

  二值化的上下游：
  灰度化 → 二值化(本课) → 轮廓检测 / OCR / 形态学运算

  阈值选择的进化：
  手动阈值 → Otsu 自动(本课) → 自适应阈值(延伸) → 深度学习分割
```

---

## 十二、记忆口诀

```
🧠 二值化核心：

  "大于 T 给白色，小于 T 给黑色"
  dst = src > T ? 255 : 0

🧠 Otsu 原理：

  "大津找阈值，类间方差最大化"
  不用猜 T 是多少，让数据自己决定

🧠 何时用二值化：

  "轮廓检测提前做，OCR 必须先二值"
  findContours / tesseract 的输入都要二值图

🧠 threshold 五兄弟复习：

  "课程 08 讲了五种，本课重点 BINARY"
  BINARY = 阶梯函数（跳变）
  TRUNC = 截断函数（课程 08 重点）
```

---

## 十三、新手雷区

```cpp
// ❌ 雷区 1：二值化后全白或全黑
cv::threshold(gray, dst, 10, 255, cv::THRESH_BINARY);
// 阈值太低 → 几乎所有像素 > 10 → 全白

// ✅ 正确：不确定阈值就用 Otsu
cv::threshold(gray, dst, 0, 255, cv::THRESH_BINARY | cv::THRESH_OTSU);
// Otsu 自动选最佳阈值，第三个参数写什么都不影响
```

```cpp
// ❌ 雷区 2：对彩色图直接二值化
cv::threshold(colorImg, dst, 128, 255, cv::THRESH_BINARY);
// 多通道二值化结果混乱

// ✅ 正确：先转灰度
cv::Mat gray;
cv::cvtColor(colorImg, gray, cv::COLOR_BGR2GRAY);
cv::threshold(gray, dst, 128, 255, cv::THRESH_BINARY);
```

```cpp
// ❌ 雷区 3：光照不均匀还用全局阈值
cv::threshold(unevenLit, dst, 128, 255, cv::THRESH_BINARY);
// 左半亮右半暗 → 右半全黑

// ✅ 正确：用自适应阈值
cv::adaptiveThreshold(unevenLit, dst, 255,
    cv::ADAPTIVE_THRESH_GAUSSIAN_C,
    cv::THRESH_BINARY, 11, 2);
// 每个像素根据邻域自动选阈值
```

---

## 十四、思考题

1. **Otsu 算法返回的阈值可以获取吗？怎么获取？**
   提示：`double otsuT = cv::threshold(...)` 的返回值就是……

2. **二值化后的图像做反相（课程 10），等价于用哪种阈值模式？**
   提示：`BINARY` 反相 = `BINARY_INV`。

3. **为什么扫描文档做 OCR 前要先二值化？**
   提示：OCR 引擎通常只处理黑白两种，灰度信息是噪声。

---

## 十五、速查卡片

```
┌─────────────────── 课程 11 速查 ───────────────────┐
│                                                    │
│  基本二值化:                                        │
│    cv::threshold(gray, dst, T, 255, BINARY);       │
│    效果: dst = src > T ? 255 : 0                   │
│                                                    │
│  Otsu 自动阈值:                                     │
│    double T = cv::threshold(gray, dst, 0, 255,     │
│               BINARY | THRESH_OTSU);               │
│    返回值 T 就是 Otsu 算法选出的最佳阈值             │
│                                                    │
│  自适应阈值（光照不均匀时）:                          │
│    cv::adaptiveThreshold(gray, dst, 255,           │
│        ADAPTIVE_THRESH_GAUSSIAN_C,                 │
│        THRESH_BINARY, blockSize, C);               │
│                                                    │
│  二值化 → 轮廓检测:                                 │
│    findContours(binary, contours,                  │
│                 RETR_EXTERNAL, CHAIN_APPROX_SIMPLE);│
│                                                    │
└────────────────────────────────────────────────────┘
```

---

## 十六、延伸阅读

- [cv::threshold 文档](https://docs.opencv.org/4.x/d7/d1b/group__imgproc__misc.html#gae8a4a146d1ca78c626a53577199e9c57) — threshold + Otsu 完整说明
- [cv::adaptiveThreshold 文档](https://docs.opencv.org/4.x/d7/d1b/group__imgproc__misc.html#ga72b913f352e4a1b1b397736707afcde3) — 自适应阈值
- [Otsu 算法教程](https://docs.opencv.org/4.x/d7/d4d/tutorial_py_thresholding.html) — OpenCV 官方 Otsu 教程
