# 课程 04：形态学操作——腐蚀与膨胀

> 适合人群：零基础初学者 | 预计阅读时间：30 分钟

---

## 零、预备知识

### 什么是形态学？

**形态学（Morphology）** 这个词来自生物学，意思是"研究形状和结构"。在图像处理中，形态学操作是一系列**基于形状**的图像变换技术——用一个小形状（叫"结构元素"或"核"）在图片上滑动扫描，改变局部区域的像素。

```
形态学操作的核心思想：

  一个小形状（核）在图片上"扫描"
  ┌─────────────────────────┐
  │           ┌───┐          │
  │  图片     │核 │ ──扫描──▶│  扫描过程中，根据规则
  │           └───┘          │  修改中心像素的值
  │                          │
  └─────────────────────────┘
```

### 什么是"核"（Kernel / Structuring Element）？

核是一个小的矩形（或其他形状），用来定义"看周围多大范围"：

```
3×3 的矩形核：          5×5 的矩形核：          3×3 的十字核：

  ■ ■ ■                 ■ ■ ■ ■ ■              · ■ ·
  ■ ● ■                 ■ ■ ■ ■ ■              ■ ● ■
  ■ ■ ■                 ■ ■ ● ■ ■              · ■ ·
                         ■ ■ ■ ■ ■
  ● = 中心               ■ ■ ■ ■ ■             只看上下左右
  ■ = 参与计算的位置                              不看对角
```

核越大，操作的影响范围越广。

---

## 一、本课目标

本课你将学会：

1. **腐蚀（Erode）** 的原理和效果——让物体"缩小"
2. **膨胀（Dilate）** 的原理和效果——让物体"扩大"
3. 用 **Trackbar（滑动条）** 交互控制操作强度
4. 在**彩色 / 灰度 / 二值图**上观察不同效果

---

## 二、腐蚀（Erode）详解

### 2.1 腐蚀的直观理解

**腐蚀 = 让亮区域缩小、暗区域扩大**

想象一下"橡皮擦沿着白色物体的边缘擦"：

```
原图（白色物体在黑色背景上）：      腐蚀后：

  ░░░░░░░░░░░░░░                   ░░░░░░░░░░░░░░
  ░░░░████████░░                   ░░░░░░████░░░░
  ░░░█████████░░                   ░░░░░██████░░░
  ░░░█████████░░      ───▶         ░░░░░██████░░░
  ░░░█████████░░     腐蚀          ░░░░░██████░░░
  ░░░░████████░░                   ░░░░░░████░░░░
  ░░░░░░░░░░░░░░                   ░░░░░░░░░░░░░░

  白色区域变小了！
  像是被"腐蚀"掉一圈
```

### 2.2 腐蚀的数学定义

对于核覆盖的区域，取**最小值**作为中心像素的新值：

$$
\text{dst}(x,y) = \min_{(i,j) \in \text{kernel}} \text{src}(x+i, y+j)
$$

```
3×3 核的腐蚀过程（灰度图）：

  原图像素值：              腐蚀后中心值：
  ┌─────┬─────┬─────┐
  │ 200 │ 180 │ 190 │      min(200, 180, 190,
  ├─────┼─────┼─────┤           150, 170, 160,
  │ 150 │[170]│ 160 │           140, 130, 155)
  ├─────┼─────┼─────┤      = 130
  │ 140 │ 130 │ 155 │
  └─────┴─────┴─────┘      中心的 170 → 变成 130（变暗了）

  取最小值 → 暗像素会"赢"→ 亮区域缩小 → 暗区域扩大
```

```
不同像素值场景下的腐蚀效果：

  场景 1：全白区域                场景 2：边缘处
  ┌─────┬─────┬─────┐           ┌─────┬─────┬─────┐
  │ 255 │ 255 │ 255 │           │ 255 │ 255 │ 0   │
  ├─────┼─────┼─────┤           ├─────┼─────┼─────┤
  │ 255 │ 255 │ 255 │           │ 255 │[255]│ 0   │
  ├─────┼─────┼─────┤           ├─────┼─────┼─────┤
  │ 255 │ 255 │ 255 │           │ 255 │ 255 │ 0   │
  └─────┴─────┴─────┘           └─────┴─────┴─────┘
  min = 255（不变）              min = 0（白→黑！边缘被腐蚀）
```

### 2.3 OpenCV 函数

```cpp
cv::erode(src,          // 输入图片
          dst,          // 输出图片
          kernel);      // 结构元素（核）
```

创建核：

```cpp
// 方法 1：自动创建矩形核
int k = erodeSize * 2 + 1;  // k 必须是奇数（有中心点）
cv::Mat kernel = cv::getStructuringElement(cv::MORPH_RECT, cv::Size(k, k));

// k=1 → 1×1（无效果）  k=3 → 3×3  k=5 → 5×5  k=7 → 7×7
```

为什么核大小必须是**奇数**？

```
奇数核（3×3）：有明确的中心   偶数核（4×4）：中心在哪里？
  ■ ■ ■                        ■ ■ ■ ■
  ■ ● ■  ← 这个是中心          ■ ? ? ■  ← 没有明确中心
  ■ ■ ■                        ■ ? ? ■
                                ■ ■ ■ ■
```

---

## 三、膨胀（Dilate）详解

### 3.1 膨胀的直观理解

**膨胀 = 让亮区域扩大、暗区域缩小**

是腐蚀的反操作，想象"用白色油漆沿着白色物体的边缘多涂一圈"：

```
原图：                              膨胀后：

  ░░░░░░░░░░░░░░                   ░░░░░░░░░░░░░░
  ░░░░████████░░                   ░░░██████████░░
  ░░░█████████░░                   ░░████████████░
  ░░░█████████░░      ───▶         ░░████████████░
  ░░░█████████░░     膨胀          ░░████████████░
  ░░░░████████░░                   ░░░██████████░░
  ░░░░░░░░░░░░░░                   ░░░░░░░░░░░░░░

  白色区域变大了！
  像是往外"膨胀"了一圈
```

### 3.2 膨胀的数学定义

对于核覆盖的区域，取**最大值**作为中心像素的新值：

$$
\text{dst}(x,y) = \max_{(i,j) \in \text{kernel}} \text{src}(x+i, y+j)
$$

```
3×3 核的膨胀过程（灰度图）：

  原图像素值：              膨胀后中心值：
  ┌─────┬─────┬─────┐
  │ 50  │ 80  │ 60  │      max(50, 80, 60,
  ├─────┼─────┼─────┤           70, 90, 100,
  │ 70  │[ 90]│ 100 │           40, 85, 95)
  ├─────┼─────┼─────┤      = 100
  │ 40  │ 85  │ 95  │
  └─────┴─────┴─────┘      中心的 90 → 变成 100（变亮了）

  取最大值 → 亮像素会"赢"→ 亮区域扩大 → 暗区域缩小
```

### 3.3 OpenCV 函数

```cpp
cv::dilate(src, dst, kernel);
```

用法和 `erode` 完全一样，只是效果相反。

**核大小对腐蚀/膨胀效果的影响参考表**：

| erodeSize | 核大小 k | 影响范围 | 腐蚀效果 | 膨胀效果 | 适用场景 |
|----------|---------|---------|---------|---------|---------|
| 0 | 1×1 | 0 像素 | 无变化 | 无变化 | — |
| 1 | 3×3 | 1 像素 | 轻微缩小 | 轻微扩大 | 微调、去单像素噪点 |
| 2 | 5×5 | 2 像素 | 明显缩小 | 明显扩大 | 一般用途（推荐起点） |
| 3 | 7×7 | 3 像素 | 较强缩小 | 较强扩大 | 粗线条、大噪点 |
| 5 | 11×11 | 5 像素 | 强烈缩小 | 强烈扩大 | 大面积形态学操作 |
| 10 | 21×21 | 10 像素 | 极端缩小 | 极端扩大 | 特殊场景 |

> **规律**：`k = erodeSize × 2 + 1`，影响范围 = `erodeSize` 像素。  
> 小核多次迭代 ≈ 大核一次操作，但边界细节略有差异。

---

## 四、腐蚀 vs 膨胀对比

```
腐蚀 (Erode)                    膨胀 (Dilate)
─────────────                   ─────────────
取最小值 min                    取最大值 max
亮区域缩小                      亮区域扩大
暗区域扩大                      暗区域缩小
消除小白点（噪声）              填充小黑洞
使细线变细甚至断裂              使细线变粗
边界向内收缩                    边界向外扩展
```

| 操作 | 效果 | 数学 | 应用场景 |
|------|------|------|---------|
| 腐蚀 | 缩小亮区 | min | 去噪点、分离粘连物体 |
| 膨胀 | 扩大亮区 | max | 填空洞、连接断裂 |
| 先腐后膨（开运算） | 去除小噪点但保持大小不变 | erode → dilate | 去噪声 |
| 先膨后腐（闭运算） | 填充小空洞但保持大小不变 | dilate → erode | 填空洞 |

**形态学操作全家福**：

| 操作 | 公式 | 对亮区域 | 对暗区域 | 边界 | 主要用途 |
|------|------|---------|---------|------|---------|
| 腐蚀 | min | 缩小 ↓ | 扩大 ↑ | 内缩 | 去白噪点、分离粘连 |
| 膨胀 | max | 扩大 ↑ | 缩小 ↓ | 外扩 | 填黑洞、连接断裂 |
| 开运算 | erode→dilate | ≈不变 | ≈不变 | 平滑 | 去白噪点保形状 |
| 闭运算 | dilate→erode | ≈不变 | ≈不变 | 平滑 | 填黑洞保形状 |
| 梯度 | dilate−erode | — | — | 提取 | 边缘检测（下节课） |
| 顶帽 | src−open | 提取小亮点 | — | — | 不均匀光照补偿 |
| 黑帽 | close−src | — | 提取小暗点 | — | 暗细节增强 |

> 所有操作都通过 `cv::morphologyEx(src, dst, op, kernel)` 一个函数调用。

```
操作对比示意：

  腐蚀                        膨胀                        开运算                      闭运算
  ┌──────────┐              ┌──────────┐              ┌──────────┐              ┌──────────┐
  │ ░░████░░ │              │ ░░████░░ │              │ ░░████░░ │              │ ░░████░░ │
  │ ░░████░░ │ → 腐蚀 →     │ ░░████░░ │ → 膨胀 →     │ ░██████░ │ → 开运算 →   │ ░██░███░ │ → 闭运算 →
  │ ░░████░░ │              │ ░░████░░ │              │ ░░████░░ │              │ ░░████░░ │
  └──────────┘              └──────────┘              └──────────┘              └──────────┘
  ┌──────────┐              ┌──────────┐              ┌──────────┐              ┌──────────┐
  │ ░░░██░░░ │              │ ░██████░ │              │ ░░████░░ │              │ ░████████ │
  │ ░░░██░░░ │              │ ██████░░ │              │ ░░████░░ │              │ ░░████░░ │
  │ ░░░██░░░ │              │ ░██████░ │              │ ░░████░░ │              │ ░░████░░ │
  └──────────┘              └──────────┘              └──────────┘              └──────────┘
  物体缩小                    物体扩大                   去掉噪点保持大小            填上空洞保持大小
```

```
开运算 vs 闭运算示意：

原图（有噪点和空洞）：
  ░░░░░██░░░░░░░░
  ░░░████████░░░░
  ░░░████░███░░░░   ← 中间有空洞
  ░░░████████░░░░
  ░░░░░░░░░░░░░░░
  ░░██░░░░░░░░░░░   ← 孤立噪点

开运算（去噪点）：          闭运算（填空洞）：
  ░░░░░░░░░░░░░░░          ░░░░░██░░░░░░░░
  ░░░████████░░░░          ░░░████████░░░░
  ░░░████░███░░░░          ░░░█████████░░░  ← 空洞填上了
  ░░░████████░░░░          ░░░████████░░░░
  ░░░░░░░░░░░░░░░          ░░░░░░░░░░░░░░░
  ░░░░░░░░░░░░░░░ ←噪点没了 ░░██░░░░░░░░░░░
```

---

## 五、Trackbar（滑动条）

### 5.1 createTrackbar

```cpp
cv::createTrackbar(const std::string& trackbarName,   // 滑动条名称
                   const std::string& windowName,      // 所在窗口
                   int* value,                         // 绑定的变量
                   int count,                          // 最大值
                   cv::TrackbarCallback onChange,       // 值变化时的回调
                   void* userdata);                    // 用户数据
```

```
Trackbar 的工作原理：

                      ┌── Trackbar ──────────────────────┐
  OpenCV 窗口         │  Erode ═══●════════════════  3    │
  ┌───────────────────┤  Dilate ════════●══════════  5    │
  │                   └──────────────────────────────────┘
  │  🐱 图片                      │
  │                                │ 用户拖动滑块
  │                                ▼
  │                        onChange(3, userdata)
  │                        → state->erodeSize = 3
  │                        → applyMorphology(state)
  │                        → erode + imshow
  └───────────────────────────────────────────────────────
```

### 5.2 本课中的使用

```cpp
// 创建两个滑动条
cv::createTrackbar("Erode", windowName, &state.erodeSize, 10, onErodeTrackbar, &state);
cv::createTrackbar("Dilate", windowName, &state.dilateSize, 10, onDilateTrackbar, &state);

// 回调函数
void onErodeTrackbar(int value, void *userdata)
{
    auto *state = static_cast<MorphologyState *>(userdata);
    state->erodeSize = value;
    applyMorphology(state);  // 重新应用并显示
}
```

---

## 六、三种图像模式

本课支持在三种不同的图像模式下观察腐蚀/膨胀的效果：

```cpp
// 模式 0：彩色图
state->display = state->original.clone();

// 模式 1：灰度图
cv::cvtColor(state->original, state->display, cv::COLOR_BGR2GRAY);

// 模式 2：二值图（黑白分明，最能展示形态学效果）
cv::Mat gray;
cv::cvtColor(state->original, gray, cv::COLOR_BGR2GRAY);
cv::threshold(gray, state->display, 0, 255, cv::THRESH_BINARY | cv::THRESH_OTSU);
```

**为什么二值图最能展示效果？**

```
灰度图上腐蚀/膨胀：             二值图上腐蚀/膨胀：

  渐变过渡，效果不明显            黑白分明，效果一目了然
  ┌────────────────┐            ┌────────────────┐
  │ ░░▒▒▓▓██▓▓▒▒░░│            │ ░░░░████████░░░│
  │ 连续灰度值     │            │ 只有 0 和 255   │
  │ 看不太出变化   │            │ 边界清晰可见    │
  └────────────────┘            └────────────────┘
```

> **THRESH_OTSU**：Otsu（大津）算法，自动找到最佳的阈值来将灰度图分为黑白两部分。不需要手动指定阈值，算法会根据图片内容自动计算。

**三种图像模式下的形态学操作效果对比**：

| 特性 | 彩色图 (mode=0) | 灰度图 (mode=1) | 二值图 (mode=2) |
|------|----------------|----------------|----------------|
| 通道数 | 3 (BGR) | 1 | 1 |
| 像素值 | 0~255 × 3 | 0~255 | 只有 0 和 255 |
| 腐蚀效果 | 颜色变暗变混 | 变暗 | 白色区域缩小 |
| 膨胀效果 | 颜色变亮变混 | 变亮 | 白色区域扩大 |
| 边界清晰度 | ⭐⭐ 一般 | ⭐⭐⭐ 较好 | ⭐⭐⭐⭐⭐ 最清晰 |
| 推荐观察 | 了解彩色影响 | 灰度过渡 | **最佳学习模式** |

---

## 七、完整处理流程

```cpp
void applyMorphology(MorphologyState *state)
{
    // 1. 根据模式选择图像
    if (state->mode == 1)
        cv::cvtColor(state->original, state->display, cv::COLOR_BGR2GRAY);
    else if (state->mode == 2) {
        cv::Mat gray;
        cv::cvtColor(state->original, gray, cv::COLOR_BGR2GRAY);
        cv::threshold(gray, state->display, 0, 255, THRESH_BINARY | THRESH_OTSU);
    } else
        state->display = state->original.clone();

    // 2. 应用腐蚀
    if (state->erodeSize > 0) {
        int k = state->erodeSize * 2 + 1;
        cv::Mat kernel = cv::getStructuringElement(MORPH_RECT, Size(k, k));
        cv::erode(state->display, state->display, kernel);
    }

    // 3. 应用膨胀
    if (state->dilateSize > 0) {
        int k = state->dilateSize * 2 + 1;
        cv::Mat kernel = cv::getStructuringElement(MORPH_RECT, Size(k, k));
        cv::dilate(state->display, state->display, kernel);
    }

    // 4. 显示结果
    cv::imshow(state->windowName, state->display);
}
```

```
数据流：

  原图 ──▶ 模式转换 ──▶ 腐蚀 ──▶ 膨胀 ──▶ 显示
  │        ┌──────┐    ┌────┐   ┌────┐    ┌──────┐
  │        │彩色  │    │min │   │max │    │imshow│
  │        │灰度  │    │操作│   │操作│    │      │
  │        │二值  │    └────┘   └────┘    └──────┘
  │        └──────┘
  └─ cat.jpg
```

---

## 八、动手实验

### 实验 1：不同核形状

```cpp
// 矩形核
cv::Mat rect = cv::getStructuringElement(cv::MORPH_RECT, cv::Size(5, 5));

// 十字核
cv::Mat cross = cv::getStructuringElement(cv::MORPH_CROSS, cv::Size(5, 5));

// 椭圆核
cv::Mat ellipse = cv::getStructuringElement(cv::MORPH_ELLIPSE, cv::Size(5, 5));

// 对比三种核的腐蚀效果
```

### 实验 2：实现开运算和闭运算

```cpp
// 开运算 = 先腐蚀后膨胀（去噪点）
cv::morphologyEx(src, dst, cv::MORPH_OPEN, kernel);

// 闭运算 = 先膨胀后腐蚀（填空洞）
cv::morphologyEx(src, dst, cv::MORPH_CLOSE, kernel);

// 梯度 = 膨胀 - 腐蚀（提取边缘，下节课内容！）
cv::morphologyEx(src, dst, cv::MORPH_GRADIENT, kernel);
```

---

## 九、常见问题

| 问题 | 原因 | 解决方法 |
|------|------|---------|
| 腐蚀后图片全黑了 | 核太大 | 减小 erodeSize |
| 膨胀后图片全白了 | 核太大或图片本来就亮 | 减小 dilateSize |
| 效果不明显 | 在灰度图上看不清 | 切换到二值模式 |
| 滑动条没反应 | 没调用 waitKey | 确保 QTimer 在运行 |
| 想恢复原图 | 需要保留原始图片 | 始终从 original 重新处理 |

---

## 十、术语表

| 术语 | 英文 | 含义 |
|------|------|------|
| 腐蚀 | Erosion / Erode | 取局部最小值，缩小亮区域 |
| 膨胀 | Dilation / Dilate | 取局部最大值，扩大亮区域 |
| 结构元素 | Structuring Element | 定义操作范围的小核 |
| 开运算 | Opening | 先腐蚀后膨胀 |
| 闭运算 | Closing | 先膨胀后腐蚀 |
| 形态学 | Morphology | 基于形状的图像变换操作 |
| 滑动条 | Trackbar | OpenCV 窗口中的交互控件 |
| 二值图 | Binary Image | 只有黑（0）和白（255）的图像 |
| Otsu | 大津法 | 自动求最佳二值化阈值的算法 |

---

## 十一、知识地图

```
  ① 生成保存 → ② 读取显示 → ③ 窗口交互
                                  ↓
                             ④ 腐蚀与膨胀 → ⑤ 边界提取
                                ★ 本课        ↑ 用腐蚀做差

  本课是"邻域运算"的入门，也是形态学操作的基础。
  后续课程 05 会用本课学的腐蚀来提取边界。
  课程 06~12 转向"点运算"（每个像素独立处理）。
```

---

## 十二、记忆口诀

```
🧠 腐蚀膨胀核心：

  "腐小膨大，最值说了算"
  ─────────────────────
  腐蚀 = 取最小值 → 亮区变小 → 像被"腐蚀"
  膨胀 = 取最大值 → 亮区变大 → 像在"膨胀"

🧠 开运算闭运算：

  "先腐后膨开（开门去灰尘），先膨后腐闭（关门填空洞）"
  ───────────────────────────────────────────────
  开运算 MORPH_OPEN  = erode → dilate  → 去小白点
  闭运算 MORPH_CLOSE = dilate → erode  → 填小黑洞

🧠 核大小口诀：

  "核要奇数有中心，越大效果越明显"
  k = size * 2 + 1  →  保证是奇数
```

---

## 十三、新手雷区

```cpp
// ❌ 雷区 1：核大小用了偶数
cv::Mat kernel = cv::getStructuringElement(cv::MORPH_RECT, cv::Size(4, 4));
// 偶数核没有明确的中心点，结果可能偏移！

// ✅ 正确：始终用奇数
cv::Mat kernel = cv::getStructuringElement(cv::MORPH_RECT, cv::Size(5, 5));
```

```cpp
// ❌ 雷区 2：在原图上反复操作（迭代腐蚀）
cv::erode(image, image, kernel);  // 第一次
cv::erode(image, image, kernel);  // 在上一次结果上再腐蚀
// 效果等同于用更大的核腐蚀一次，但没法恢复了！

// ✅ 正确：保留原图
cv::Mat original = image.clone();
cv::erode(original, result, kernel);  // 不破坏原始数据
```

```cpp
// ❌ 雷区 3：把开运算的顺序搞反
// 想去噪点，却先膨胀再腐蚀（这是闭运算，填空洞用的！）
cv::dilate(src, temp, kernel);
cv::erode(temp, dst, kernel);    // ← 这是闭运算

// ✅ 正确：用 morphologyEx 避免搞混
cv::morphologyEx(src, dst, cv::MORPH_OPEN, kernel);   // 开运算
cv::morphologyEx(src, dst, cv::MORPH_CLOSE, kernel);  // 闭运算
```

---

## 十四、思考题

1. **如果对一张全白图（所有像素=255）做腐蚀，结果是什么？**
   提示：min(255, 255, ..., 255) = ?

2. **开运算可以消除小白点，那如何消除小黑点呢？**
   提示：小黑点是"暗区域的小噪声"……

3. **腐蚀 10 次（3×3 核）和腐蚀 1 次（21×21 核）的效果一样吗？**
   提示：理论上近似，但边界效果有微妙差异。

---

## 十五、速查卡片

```
┌─────────────────── 课程 04 速查 ───────────────────┐
│                                                    │
│  创建核:                                            │
│    cv::getStructuringElement(shape, Size(k,k))     │
│    shape: MORPH_RECT / MORPH_CROSS / MORPH_ELLIPSE │
│                                                    │
│  腐蚀:  cv::erode(src, dst, kernel);               │
│  膨胀:  cv::dilate(src, dst, kernel);              │
│                                                    │
│  组合操作:                                          │
│    cv::morphologyEx(src, dst, op, kernel);          │
│    MORPH_OPEN   = 先腐后膨（去噪点）                │
│    MORPH_CLOSE  = 先膨后腐（填空洞）                │
│    MORPH_GRADIENT = 膨胀 - 腐蚀（边缘）             │
│                                                    │
│  滑动条:                                            │
│    cv::createTrackbar(name, win, &val, max, cb);   │
│                                                    │
└────────────────────────────────────────────────────┘
```

---

## 十六、延伸阅读

- [cv::erode 文档](https://docs.opencv.org/4.x/d4/d86/group__imgproc__filter.html#gaeb1e0c1033e3f6b891a25d0511362aeb) — 腐蚀函数参数详解
- [cv::morphologyEx 文档](https://docs.opencv.org/4.x/d4/d86/group__imgproc__filter.html#ga67493776e3ad1a3df63883829375201f) — 所有形态学操作
- [形态学变换教程](https://docs.opencv.org/4.x/d9/d61/tutorial_py_morphological_ops.html) — OpenCV 官方形态学教程
